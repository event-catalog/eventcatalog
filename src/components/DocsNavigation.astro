---
import { getCommands } from '@utils/commands';
import { getDomains } from '@utils/domains/domains';
import { getEvents } from '@utils/events';
import { getServices } from '@utils/services/services';
import { getFlows } from '@utils/flows/flows';
import { getTeams } from '@utils/teams';
import { getUsers } from '@utils/users';
import config, { type CatalogConfig } from '@eventcatalog';
import { buildUrl } from '@utils/url-builder';
import BasicList from './Lists/BasicList';

const [events, commands, services, domains, flows, teams, users] = await Promise.all([
  getEvents({ getAllVersions: false }),
  getCommands({ getAllVersions: false }),
  getServices({ getAllVersions: false }),
  getDomains({ getAllVersions: false }),
  getFlows({ getAllVersions: false }),
  getTeams(),
  getUsers(),
]);

const messages = [...events, ...commands];

// @ts-ignore for large catalogs https://github.com/event-catalog/eventcatalog/issues/552
const allData = [...domains, ...services, ...messages, ...flows, ...teams, ...users];

const eventCatalogConfig = config as CatalogConfig;
const {
  services: servicesConfig,
  domains: domainsConfig,
  messages: messagesConfig,
  flows: flowsConfig,
  teams: teamsConfig,
  users: usersConfig,
  showPageHeadings = true,
} = eventCatalogConfig?.docs?.sidebar || {};

const getConfigValue = (obj: any, key: string, defaultValue: any) => {
  return obj?.[key] ?? defaultValue;
};

const visibleCollections: { [key: string]: boolean } = {
  events: getConfigValue(messagesConfig, 'visible', true),
  commands: getConfigValue(messagesConfig, 'visible', true),
  domains: getConfigValue(domainsConfig, 'visible', true),
  flows: getConfigValue(flowsConfig, 'visible', true),
  services: getConfigValue(servicesConfig, 'visible', true),
  teams: getConfigValue(teamsConfig, 'visible', true),
  users: getConfigValue(usersConfig, 'visible', true),
};

const fetchHeadings = allData.map(async (item) => {
  const renderHeadings = showPageHeadings;
  const headings = renderHeadings ? await item.render() : { headings: [] };
  return {
    ...item,
    headings: headings.headings,
  };
});

const withHeadings = await Promise.all(fetchHeadings);
const currentPath = Astro.url.pathname;

const sideNav = withHeadings.reduce((acc, item) => {
  const title = item.collection === 'events' || item.collection === 'commands' ? 'Messages' : item.collection;

  const group = acc[title] || [];

  const navigationItem = {
    label: item.data.name,
    version: item.collection === 'teams' || item.collection === 'users' ? null : item.data.version,
    items: item.collection === 'users' ? [] : item.headings,
    visible: visibleCollections[item.collection],
    current: currentPath.includes(`${item.collection}`),
    // @ts-ignore
    href: item.data.version
      ? // @ts-ignore
        buildUrl(`/docs/${item.collection}/${item.data.id}/${item.data.version}`)
      : buildUrl(`/docs/${item.collection}/${item.data.id}`),
  };

  group.push(navigationItem);

  return {
    ...acc,
    [title]: group,
  };
}, {} as any);
---

<div class="font-light w-full xl:pr-10 pb-20">
  {
    Object.keys(sideNav).map((key) => {
      const collection = sideNav[key];
      if (collection[0] && collection[0].visible === false) return null;
      return (
        <BasicList
          title={`${key} (${collection.length})`}
          items={collection}
          emptyMessage="Nothing to show"
          color="gray"
          client:load
        />
      );
    })
  }
</div>

<script>
  // Scroll to the current page element
  document.addEventListener('DOMContentLoaded', () => {
    const currentPath = document.location.pathname;
    const currentElement = document.getElementById(currentPath);
    if (currentElement) {
      // scroll to the current element with padding
      currentElement.scrollIntoView({
        behavior: 'auto',
        block: 'start',
        inline: 'start',
      });
    }
  });
</script>
