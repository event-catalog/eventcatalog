// import { getCollection } from "astro:content";
import config from "@config";
import fs from 'node:fs';
import path from 'node:path';
import { getEntry } from 'astro:content';
import matter from 'gray-matter';

type SidebarItem = {
    label: string;
    slug?: string;
    items?: SidebarItem[];
}

type SideBarConfigurationItem = {
    label: string;
    items?: SidebarItem[];
    slug?: string;
    autogenerated?: {
        directory: string;
    }
}

const DOCS_DIR = 'docs';

/**
 * Processes auto-generated directory and returns navigation items
 */
const processAutoGeneratedDirectory = async (directory: string, label: string): Promise<SidebarItem> => {
    // @ts-ignore
    const files = fs.readdirSync(path.join(process.env.PROJECT_DIR || '', DOCS_DIR, directory));

    // Convert files to frontmatter
    const docsWithFrontmatter = files.map((file) => {
        // @ts-ignore
        const content = fs.readFileSync(path.join(process.env.PROJECT_DIR || '', DOCS_DIR, directory, file), 'utf8');
        const { data } = matter(content);
        return { ...data, file };
    });

    // If user defined slug use it, otherwise use the file
    const astroIdsForFiles = docsWithFrontmatter.map((doc: any) => doc.slug || path.join(DOCS_DIR, directory, doc.file).replace('.mdx', ''));

    const entries = await Promise.all(astroIdsForFiles.map(async (astroId) => {
        const entry = await getEntry('customPages', astroId);
        return entry;
    }));

    // Filter anything we haven't found
    const filteredEntries = entries.filter((entry) => entry !== undefined);
    
    return {
        label,
        items: filteredEntries.map((entry) => ({
            label: entry?.data?.title,
            slug: entry?.data?.slug || entry?.id.replace(DOCS_DIR, ''),
        })),
    };
}

/**
 * Recursively process sidebar items to handle auto-generated content at any nesting level
 */
const processSidebarItems = async (items: SideBarConfigurationItem[]): Promise<SidebarItem[]> => {
    const processedItems: SidebarItem[] = [];
    
    for (const item of items) {
        // If item has autogenerated property, process it
        if (item.autogenerated) {
            const processedItem = await processAutoGeneratedDirectory(
                item.autogenerated.directory, 
                item.label
            );
            processedItems.push(processedItem);
        } 
        // If item has nested items, process them recursively
        else if (item.items && item.items.length > 0) {
            const processedNestedItems = await processSidebarItems(item.items as SideBarConfigurationItem[]);
            processedItems.push({
                label: item.label,
                slug: item.slug,
                items: processedNestedItems
            });
        } 
        // Otherwise, it's a regular item
        else {
            processedItems.push(item as SidebarItem);
        }
    }
    
    return processedItems;
}

export const getNavigationItems = async (): Promise<SidebarItem[]> => {
    const configuredSidebar = config.customDocs.sidebar;
    return processSidebarItems(configuredSidebar as SideBarConfigurationItem[]);
}