---
// src/components/SchemaViewer.astro
import SchemaProperty from './SchemaProperty.astro';

interface Props {
  schema: Record<string, any>;
  schemaPath: string;
  title: string;
  maxHeight: string;
  file: string;
  id: string;
  expand?: boolean;
}

const { id, file, title, maxHeight, schema, expand = false } = Astro.props;

// This will be used to pass expand state via data attribute
const expandData = expand ? 'true' : 'false';

// Function to merge allOf schemas
function mergeAllOfSchemas(schemaWithProcessor: any): any {
  const { processSchema: processor, ...schema } = schemaWithProcessor;
  if (!schema.allOf) return schema;

  const mergedSchema: {
    type: string;
    properties: Record<string, any>;
    required: string[];
    description?: string;
    [key: string]: any;
  } = {
    type: schema.type || 'object',
    properties: {},
    required: [],
    description: schema.description,
  };

  // Copy base schema properties first (excluding allOf)
  Object.keys(schema).forEach((key) => {
    if (key !== 'allOf' && key !== 'properties' && key !== 'required' && key !== 'description') {
      mergedSchema[key] = schema[key];
    }
  });

  // Copy base properties if they exist
  if (schema.properties) {
    mergedSchema.properties = { ...schema.properties };
  }
  if (schema.required) {
    mergedSchema.required = [...schema.required];
  }

  schema.allOf.forEach((subSchema: any) => {
    // Recursively process each subSchema in case it has its own allOf, oneOf, or $ref
    const processedSubSchema = processor ? processor(subSchema) : subSchema;

    if (processedSubSchema.properties) {
      mergedSchema.properties = {
        ...mergedSchema.properties,
        ...processedSubSchema.properties,
      };
    }
    if (processedSubSchema.required) {
      mergedSchema.required = [...new Set([...mergedSchema.required, ...processedSubSchema.required])];
    }
    if (processedSubSchema.description && !mergedSchema.description) {
      mergedSchema.description = processedSubSchema.description;
    }

    // Copy other properties from subSchema
    Object.keys(processedSubSchema).forEach((key) => {
      if (key !== 'properties' && key !== 'required' && key !== 'description' && key !== 'type') {
        if (!mergedSchema[key]) {
          mergedSchema[key] = processedSubSchema[key];
        }
      }
    });
  });

  return mergedSchema;
}

function processSchema(schema: any, rootSchema?: any): any {
  if (!schema) return schema;

  // Set rootSchema for $ref resolution
  const root = rootSchema || schema;

  // Handle $ref
  if (schema.$ref) {
    const refPath = schema.$ref;
    let resolvedSchema = null;
    let defName = '';

    // Try draft-7 style first: #/definitions/
    if (refPath.startsWith('#/definitions/')) {
      defName = refPath.replace('#/definitions/', '');
      if (root.definitions && root.definitions[defName]) {
        resolvedSchema = root.definitions[defName];
      }
    }
    // Try 2020-12 style: #/$defs/
    else if (refPath.startsWith('#/$defs/')) {
      defName = refPath.replace('#/$defs/', '');
      if (root.$defs && root.$defs[defName]) {
        resolvedSchema = root.$defs[defName];
      }
    }
    // Try other common patterns
    else if (refPath.startsWith('#/components/schemas/')) {
      defName = refPath.replace('#/components/schemas/', '');
      if (root.components && root.components.schemas && root.components.schemas[defName]) {
        resolvedSchema = root.components.schemas[defName];
      }
    }

    if (resolvedSchema) {
      // Recursively process the referenced schema
      const processedSchema = processSchema(resolvedSchema, root);
      // Add reference info to the resolved schema
      return {
        ...processedSchema,
        _refPath: refPath,
        _refName: defName,
        _originalRef: schema.$ref,
      };
    }

    // If not found, create a placeholder schema showing the reference
    return {
      type: 'string',
      description: `Reference to ${refPath} (definition not found in root schema)`,
      title: defName || refPath.split('/').pop(),
      _refPath: refPath,
      _refName: defName,
      _refNotFound: true,
    };
  }

  if (schema.allOf) {
    return mergeAllOfSchemas({ ...schema, processSchema: (s: any) => processSchema(s, root) });
  }

  if (schema.oneOf) {
    // Process each oneOf variant and create a combined schema
    const processedVariants = schema.oneOf.map((variant: any) => {
      const processedVariant = processSchema(variant, root);
      return {
        title: processedVariant.title || variant.title || 'Unnamed Variant',
        required: processedVariant.required || variant.required || [],
        properties: processedVariant.properties || {},
        ...processedVariant,
      };
    });

    // Merge all properties from variants for display
    const allProperties: Record<string, any> = {};
    processedVariants.forEach((variant: any) => {
      if (variant.properties) {
        Object.assign(allProperties, variant.properties);
      }
    });

    return {
      ...schema,
      type: schema.type || 'object',
      properties: {
        ...(schema.properties || {}),
        ...allProperties,
      },
      variants: processedVariants,
    };
  }

  // Process nested schemas in properties
  if (schema.properties) {
    const processedProperties: Record<string, any> = {};
    Object.entries(schema.properties).forEach(([key, prop]: [string, any]) => {
      processedProperties[key] = processSchema(prop, root);
    });
    schema = { ...schema, properties: processedProperties };
  }

  // Process array items
  if (schema.type === 'array' && schema.items) {
    schema = { ...schema, items: processSchema(schema.items, root) };
  }

  return schema;
}

const processedSchema = processSchema(schema);
const { description, properties, required = [], variants } = processedSchema;

// Generate a unique ID for this instance
const instanceId = `${id}-${file}-${Math.random().toString(36).substring(2, 9)}`;
---

<div id={`${id}-${file}-SchemaViewer-client`} class="not-prose my-4" data-expand={expandData}>
  {title && <h2 class="text-3xl font-bold mb-2 !mt-0">{title}</h2>}
  <div
    class="schema-viewer p-4 bg-white overflow-y-auto rounded-lg border border-gray-100 shadow-sm font-sans"
    style={{
      maxHeight: maxHeight ? `${maxHeight}px` : `30em`,
    }}
  >
    {description && <p class="text-gray-600 text-xs mb-5">{description}</p>}

    {
      variants && (
        <div class="mb-4">
          <div class="flex items-center space-x-2">
            <span class="text-sm text-gray-600">(one of)</span>
            <select
              id={`${instanceId}-variant-selector`}
              class="form-select text-sm border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
            >
              {variants.map((variant: any, index: number) => (
                <option value={index}>{variant.title}</option>
              ))}
            </select>
          </div>
        </div>
      )
    }

    {
      properties && (
        <div id={`${instanceId}-properties`}>
          {Object.entries(properties).map(([name, details]) => (
            <SchemaProperty
              name={name}
              details={details}
              isRequired={variants ? false : required.includes(name)}
              level={0}
              expand={expand}
            />
          ))}
        </div>
      )
    }

    {!properties && <p class="text-gray-500 text-sm">Schema does not contain any properties.</p>}
  </div>
</div>

<script define:vars={{ instanceId, variants, id, file }}>
  // Check if expand is set via data attribute (from portal movement)
  function checkAndExpandAll() {
    const schemaViewerClient = document.getElementById(`${id}-${file}-SchemaViewer-client`);
    if (schemaViewerClient && schemaViewerClient.getAttribute('data-expand') === 'true') {
      // Find all toggle buttons within this schema viewer
      const toggleButtons = schemaViewerClient.querySelectorAll('.property-toggle');
      toggleButtons.forEach((button) => {
        if (button.getAttribute('aria-expanded') === 'false') {
          button.click(); // Trigger the existing toggle logic
        }
      });
    }
  }

  if (variants) {
    const selector = document.getElementById(`${instanceId}-variant-selector`);
    const propertiesContainer = document.getElementById(`${instanceId}-properties`);

    function updateRequiredFields() {
      const selectedVariant = variants[selector.value];
      const properties = propertiesContainer.querySelectorAll('.property-container');

      properties.forEach((prop) => {
        const nameEl = prop.querySelector('.font-semibold');
        if (!nameEl) return;

        const name = nameEl.textContent;
        const requiredBadge = prop.querySelector('.text-red-600');

        if (selectedVariant.required.includes(name)) {
          if (!requiredBadge) {
            const badge = document.createElement('span');
            badge.className = 'text-red-600 text-xs ml-3 flex-shrink-0';
            badge.textContent = 'required';
            nameEl.parentElement.appendChild(badge);
          }
        } else {
          requiredBadge?.remove();
        }
      });
    }

    selector.addEventListener('change', updateRequiredFields);
    // Initialize with first variant
    updateRequiredFields();
  }

  // Check expand state after page loads and after portal movement
  document.addEventListener('astro:page-load', () => {
    // Small delay to ensure portal movement has completed
    setTimeout(checkAndExpandAll, 100);
  });

  // Also check immediately in case the component is already in place
  checkAndExpandAll();
</script>

<style>
  .schema-viewer code {
    font-family: 'Courier New', Courier, monospace;
  }
</style>
