---
const worker = new Worker("../workers/worker.ts", { type: "module" })
// worker.addEventListener("message", (event) => {
  // console.log("worker said:", event.data)
// })

// worker.postMessage("Hello")
// import worker from '../workers/worker.js';
// import { createRxDatabase, removeRxDatabase, addRxPlugin } from 'rxdb';
// import { getRxStorageDexie } from 'rxdb/plugins/storage-dexie';
// // import { RxDBDevModePlugin } from 'rxdb/plugins/dev-mode';
// import { RxDBMigrationSchemaPlugin } from 'rxdb/plugins/migration-schema';
// import { RxDBQueryBuilderPlugin } from 'rxdb/plugins/query-builder';
// import { RxDBUpdatePlugin } from 'rxdb/plugins/update';

// addRxPlugin(RxDBQueryBuilderPlugin);
// addRxPlugin(RxDBMigrationSchemaPlugin);
// addRxPlugin(RxDBUpdatePlugin);

// addRxPlugin(RxDBDevModePlugin);

// const itemsCollection = db.items;
// const vectorCollection = db.vector;

// import { getEvents } from '@utils/events';
// import { pipeline } from '@huggingface/transformers';

// const pipePromise = pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
// async function getEmbeddingFromText(text: string) {
//   const pipe = await pipePromise;
//   const output = await pipe(text, {
//     pooling: "mean",
//     normalize: true,
//   });
//   return Array.from(output.data);
// }

// const test = await getEmbeddingFromText('Hello, world!');
// console.log(test);

// const events = await getEvents();
// const eventsToEmbed = events[0];

// // Get the markdown for the events

// const embeddings = await Promise.all(eventsToEmbed.map(async (event: any) => {
//   const text = `# ${event.data.name}\n${event.data.summary}`;
//   const embedding = await getEmbeddingFromText(text);
//   return {
//     id: event.id,
//     embedding: embedding
//   };
// }));

// console.log(embeddings);

// const answerer = await pipeline('question-answering', 'Xenova/distilbert-base-uncased-distilled-squad');

// const events = await getEvents();

// // Fetch info from http://localhost:3000/docs/llm/llms.txt
// const llms = await fetch('http://localhost:3000/docs/llm/llms.txt');
// const context = await llms.text();

// console.log('events', events);

// // Get all events as the context
// // const context = events.map((event: any) => `There are 1000 events in this catalog`).join('\n');

// console.log(context);

// const question = 'Here is a list of events in markdown, tell me how many events there are';

// // https://huggingface.co/models?pipeline_tag=question-answering&library=transformers.js

// const result = await answerer(question, context);

// console.log(result);
---

<div>
  <div id="init-model-progress"></div>
  <ul id="results"></ul>
  <input type="number" id="inputNum" />
  <button id="sendBtn">Send</button>
  <p id="output"></p>
  <!-- <p>Result: {JSON.stringify(result)}</p> -->
</div>

<script>
  const worker = new Worker("../workers/worker.ts", { type: "module" })

  worker.addEventListener("message", (event) => {
    console.log("worker said:", event.data)
  })

  worker.postMessage("Hello")

  // import { createRxDatabase, removeRxDatabase, addRxPlugin } from 'rxdb';
  // import { getRxStorageDexie } from 'rxdb/plugins/storage-dexie';
  // import { pipeline } from '@huggingface/transformers';
  // // import { RxDBDevModePlugin } from 'rxdb/plugins/dev-mode';
  // import { RxDBMigrationSchemaPlugin } from 'rxdb/plugins/migration-schema';
  // import { RxDBQueryBuilderPlugin } from 'rxdb/plugins/query-builder';
  // import { RxDBUpdatePlugin } from 'rxdb/plugins/update';
  // import { euclideanDistance } from 'rxdb/plugins/vector';
  // import { getFromMapOrThrow } from 'rxdb/plugins/core';
  // import { sortByObjectNumberProperty } from 'rxdb/plugins/core';
  // import embeddings from '../ai/eventcatalog/embeddings.json';
  // import items from '../ai/eventcatalog/resources.json';
  // import { CreateMLCEngine } from '@mlc-ai/web-llm';

  // import { WebWorkerMLCEngineHandler } from '@mlc-ai/web-llm';

  // const myWorker = new Worker(new URL("worker.js", import.meta.url));

  //   // A handler that resides in the worker thread
  // const handler = new WebWorkerMLCEngineHandler();
  // self.onmessage = (msg: MessageEvent) => {
  //   handler.onmessage(msg);
  // };

  // on dom loaded
  // document.addEventListener('DOMContentLoaded', async () => {
  //   // Callback function to update model loading progress
  //   const initProgressCallback = (initProgress) => {
  //     console.log(initProgress);
  //     // document.getElementById('init-model-progress')?.innerHTML = `Loading model: ${initProgress.progress}, ${initProgress.text}`;
  //   };
  //   const selectedModel = 'Llama-3.1-8B-Instruct-q4f32_1-MLC';

  //   const engine = await CreateMLCEngine(
  //     selectedModel,
  //     { initProgressCallback: initProgressCallback } // engineConfig
  //   );
  //   const messages = [
  //     { role: 'system', content: 'You are a helpful AI assistant.' },
  //     { role: 'user', content: 'Hello!' },
  //   ];

  //   const reply = await engine.chat.completions.create({
  //     messages,
  //   });
  //   console.log(reply.choices[0].message);
  //   console.log(reply.usage);
  // });

  // const pipePromise = pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');

  // const getVectorFromText = async (text: string) => {
  //   const pipe = await pipePromise;
  //   const output = await pipe(text, {
  //     pooling: 'mean',
  //     normalize: true,
  //   });
  //   return Array.from(output.data);
  // };

  // const main = async () => {
  //   let database;

  //   database = await createRxDatabase({
  //     name: Math.random().toString(36).substring(2, 15),
  //     storage: getRxStorageDexie(),
  //     //   ignoreDuplicate: true,
  //   });

  //   await database.addCollections({
  //     items: {
  //       schema: {
  //         version: 0,
  //         primaryKey: 'id',
  //         type: 'object',
  //         properties: {
  //           id: {
  //             type: 'string',
  //             maxLength: 20,
  //           },
  //           text: {
  //             type: 'string',
  //           },
  //         },
  //         required: ['id', 'text'],
  //       },
  //     },
  //     vector: {
  //       schema: {
  //         version: 0,
  //         primaryKey: 'id',
  //         type: 'object',
  //         properties: {
  //           id: {
  //             type: 'string',
  //             maxLength: 20,
  //           },
  //           embedding: {
  //             type: 'array',
  //             items: {
  //               type: 'string',
  //             },
  //           },
  //         },
  //         required: ['id', 'embedding'],
  //       },
  //     },
  //   });

  //   // Get the items
  //   // console.log('embeddingsResponse', embeddings);

  //   // Insert the embeddings into the vector collection
  //   const vectorInsertResult = await database.vector.bulkInsert(embeddings);
  //   console.dir({ vectorInsertResult, embeddings });

  //   // Insert the items into the items collection
  //   await database.items.bulkInsert(items);

  //   async function vectorSearchFullScan(vectorCollection: RxCollection, searchEmbedding: number[]) {
  //     const candidates = await vectorCollection.find().exec();
  //     console.log('after fetch ' + performance.now());
  //     const withDistance = candidates.map((doc) => ({ doc, distance: euclideanDistance(searchEmbedding, doc.embedding) }));
  //     console.log('after distance ' + performance.now());
  //     const queryResult = withDistance.slice(0).sort(sortByObjectNumberProperty('distance')).reverse();
  //     console.log('after sorted ' + performance.now());
  //     console.dir({ withDistance, queryResult });
  //     return {
  //       result: queryResult.slice(0, 10),
  //       docReads: candidates.length,
  //     };
  //   }

  //   // const itemsCollection = database.items;
  //   // const vectorCollection = database.vector;

  //   // const embedding = await getVectorFromText('Dave is a new yorker');

  //   // console.log(embedding);

  //   // await vectorCollection.upsert({
  //   //   id: 1,
  //   //   embedding,
  //   // });

  //   const userInput = 'What inventory events do we have ';

  //   const searchEmbedding = await getVectorFromText(userInput);

  //   // time('START SEARCH vectorSearchFullScan ' + performance.now());
  //   const results = await vectorSearchFullScan(database.vector, searchEmbedding);
  //   // const queryResultFullScanTime = time('DONE SEARCH vectorSearchFullScan ' + performance.now());
  //   console.log({ results });

  //   const sourceDocs = await database.items.findByIds(results.result.map((r: any) => r.doc.primary)).exec();

  //   const testing = results.result
  //     .map((r: any, idx) => {
  //       const doc = getFromMapOrThrow(sourceDocs, r.doc.primary);
  //       console.log('doc', doc);
  //       // Add an LI to the results list add the doc._data.id and the doc._data.name
  //       const li = document.createElement('li');
  //       li.textContent = `${doc._data.id} - ${doc._data.name}`;
  //       document.getElementById('results')?.appendChild(li);
  //       return doc._data.name;
  //     })
  //     .join('');

  //   console.log('testsssss', testing);

  //   // Define the list of messages
  //   const messages = [
  //     { role: 'system', content: 'You are a helpful assistant.' },
  //     { role: 'user', content: 'Tell me a funny joke.' },
  //   ];

  //   // Generate a response
  //   // const queryResult = withDistance.sort(sortByObjectNumberProperty('distance')).reverse();
  //   // console.dir(queryResult);

  //   // await itemsCollection.insert({
  //   //   id: '1',
  //   //   text: 'Hello, world!',
  //   // });

  //   // This will get the items and embed them into IndedDB and Vector store
  //   // Then search the vector store for the closest matches
  //   // Then return the items and the matches based on user input search....
  // };

  // main();
</script>
