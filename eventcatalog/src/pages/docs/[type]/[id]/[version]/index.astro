---
import VerticalSideBarLayout from '@layouts/VerticalSideBarLayout.astro';
import Footer from '@layouts/Footer.astro';

import components from '@components/MDX/components';
import NodeGraph from '@components/MDX/NodeGraph/NodeGraph.astro';
import SchemaViewer from '@components/MDX/SchemaViewer/SchemaViewer.astro';

// SideBars
import ServiceSideBar from '@components/SideBars/ServiceSideBar.astro';
import MessageSideBar from '@components/SideBars/MessageSideBar.astro';
import DomainSideBar from '@components/SideBars/DomainSideBar.astro';
import ChannelSideBar from '@components/SideBars/ChannelSideBar.astro';

import { QueueListIcon, RectangleGroupIcon, ServerIcon, BoltIcon, ChatBubbleLeftIcon } from '@heroicons/react/24/outline';
import type { PageTypes } from '@types';

import { buildUrl } from '@utils/url-builder';
import { getFlows } from '@utils/collections/flows';
import { pageDataLoader } from '@utils/page-loaders/page-data-loader';
import { ViewTransitions } from 'astro:transitions';
import { ArrowsRightLeftIcon } from '@heroicons/react/20/solid';

import config from '@config';

type PageTypesWithFlows = PageTypes | 'flows';

export async function getStaticPaths() {
  const loaders = {
    ...pageDataLoader,
    flows: getFlows,
  };

  const itemTypes: PageTypesWithFlows[] = ['events', 'commands', 'queries', 'services', 'domains', 'flows', 'channels'];
  const allItems = await Promise.all(itemTypes.map((type) => loaders[type]()));

  return allItems.flatMap((items, index) =>
    items.map((item) => ({
      params: {
        type: itemTypes[index],
        id: item.data.id,
        version: item.data.version,
      },
      props: {
        type: itemTypes[index],
        ...item,
      },
    }))
  );
}

const props = Astro.props;

const { Content } = await props.render();

// Capitalize the first letter of a string
const pageTitle = `${props.collection} | ${props.data.name}`.replace(/^\w/, (c) => c.toUpperCase());
const contentBadges = props.data.badges || [];

const getBadge = () => {
  if (props.collection === 'services') {
    return { backgroundColor: 'pink', textColor: 'pink', content: 'Service', icon: ServerIcon, class: 'text-pink-400' };
  }
  if (props.collection === 'events') {
    return { backgroundColor: 'orange', textColor: 'orange', content: 'Event', icon: BoltIcon, class: 'text-orange-400' };
  }
  if (props.collection === 'commands') {
    return { backgroundColor: 'blue', textColor: 'blue', content: 'Command', icon: ChatBubbleLeftIcon, class: 'text-blue-400' };
  }
  if (props.collection === 'domains') {
    return {
      backgroundColor: 'yellow',
      textColor: 'yellow',
      content: 'Domain',
      icon: RectangleGroupIcon,
      class: 'text-yellow-400',
    };
  }

  if (props.collection === 'flows') {
    return { backgroundColor: 'teal', textColor: 'teal', content: 'Flow', icon: QueueListIcon, class: 'text-gray' };
  }

  if (props.collection === 'channels') {
    return { backgroundColor: 'teal', textColor: 'teal', content: 'Channel', icon: ArrowsRightLeftIcon, class: 'text-gray' };
  }

  return { backgroundColor: 'teal', textColor: 'teal', content: '', icon: QueueListIcon, class: 'text-gray' };
};

const getSpecificationBadges = () => {
  const badges = [];
  const hasOpenAPISpec = !!props.data.specifications?.openapiPath;
  const hasAsyncAPISpec = !!props.data.specifications?.asyncapiPath;

  if (hasOpenAPISpec) {
    badges.push({
      backgroundColor: 'white',
      textColor: 'gray',
      content: 'OpenAPI Spec',
      iconURL: buildUrl('/icons/openapi.svg', true),
      class: 'text-black hover:underline',
      id: 'open-api-badge',
      url: buildUrl(`/docs/${props.collection}/${props.data.id}/${props.data.version}/spec`),
    });
  }

  if (hasAsyncAPISpec) {
    badges.push({
      backgroundColor: 'white',
      textColor: 'gray',
      content: 'AsyncAPI Spec',
      iconURL: buildUrl('/icons/asyncapi.svg', true),
      class: 'text-black hover:underline',
      id: 'asyncapi-badge',
      url: buildUrl(`/docs/${props.collection}/${props.data.id}/${props.data.version}/asyncapi`),
    });
  }

  return badges;
};

const badges = [getBadge(), ...contentBadges, ...getSpecificationBadges()];
---

<VerticalSideBarLayout title={pageTitle} description={props.data.summary}>
  <main class="flex sm:px-8 docs-layout h-full">
    <div class="flex docs-layout w-full">
      <div class="w-full lg:mr-2 pr-8 overflow-y-auto py-8">
        <div class="border-b border-gray-200 flex justify-between items-start md:pb-2">
          <div>
            <h2 id="doc-page-header" class="text-2xl md:text-4xl font-bold text-black">
              {props.data.name}
              <span class="">(v{props.data.version})</span>
            </h2>
            <h2 class="text-lg pt-2 text-gray-500 font-light">{props.data.summary}</h2>
            {
              badges && (
                <div class="flex flex-wrap py-2 pt-4">
                  {badges.map((badge: any) => {
                    return (
                      <a href={badge.url || '#'} class="pb-2">
                        <span
                          id={badge.id || ''}
                          class={`text-sm font-light text-gray-500 px-2 py-1 rounded-md mr-2  bg-gradient-to-b  from-${badge.backgroundColor}-100 to-${badge.backgroundColor}-200 space-x-1 border border-${badge.backgroundColor}-200 text-${badge.textColor}-800 flex items-center ${badge.class ? badge.class : ''} `}
                        >
                          {badge.icon && <badge.icon className="w-4 h-4 inline-block mr-1 " />}
                          {badge.iconURL && <img src={badge.iconURL} class="w-5 h-5 inline-block " />}
                          <span>{badge.content}</span>
                        </span>
                      </a>
                    );
                  })}
                </div>
              )
            }
          </div>
        </div>

        <div>
          {
            props.data.version !== props.data.latestVersion && (
              <div class="rounded-md bg-gradient-to-r from-purple-50 to-purple-100 p-4 not-prose my-4">
                <div class="flex">
                  <div class="flex-shrink-0">
                    <svg class="h-5 w-5 text-purple-400" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                      <path
                        fill-rule="evenodd"
                        d="M8.485 2.495c.673-1.167 2.357-1.167 3.03 0l6.28 10.875c.673 1.167-.17 2.625-1.516 2.625H3.72c-1.347 0-2.189-1.458-1.515-2.625L8.485 2.495zM10 5a.75.75 0 01.75.75v3.5a.75.75 0 01-1.5 0v-3.5A.75.75 0 0110 5zm0 9a1 1 0 100-2 1 1 0 000 2z"
                        clip-rule="evenodd"
                      />
                    </svg>
                  </div>
                  <div class="ml-3">
                    <h3 class="text-sm font-medium text-purple-800">New version found</h3>
                    <div class="mt-2 text-sm text-purple-700">
                      <p>
                        You are looking at a previous version of the {props.collection.slice(0, props.collection.length - 1)}{' '}
                        <strong>{props.data.name}</strong>.{' '}
                        <a
                          class="underline hover:text-primary block pt-2"
                          href={buildUrl(`/docs/${props.collection}/${props.data.id}/${props.data.latestVersion}`)}
                        >
                          The latest version of this {props.collection.slice(0, props.collection.length - 1)} is
                          <span>v{props.data.latestVersion}</span> &rarr;
                        </a>
                      </p>
                    </div>
                  </div>
                </div>
              </div>
            )
          }
        </div>

        <div class="prose prose-md py-4 w-full">
          <Content components={components(props)} />
        </div>
        <div>
          <!-- @ts-ignore -->
          <SchemaViewer id={props.data.id} catalog={props.catalog} />
          <NodeGraph
            id={props.data.id}
            collection={props.collection}
            version={props.data.version}
            mode="simple"
            linksToVisualiser={true}
            href={{
              label: 'Open in Visualiser',
              url: buildUrl(`/visualiser/${props.collection}/${props.data.id}/${props.data.version}`),
            }}
          />
        </div>
        <Footer />
      </div>
      <aside class="hidden lg:block sticky top-0 pb-10 w-96 overflow-y-auto py-2">
        <!-- @ts-ignore -->
        {
          (props?.collection === 'events' || props.collection === 'commands' || props.collection === 'queries') && (
            <MessageSideBar message={props} />
          )
        }
        {props?.collection === 'services' && <ServiceSideBar service={props} />}
        {props?.collection === 'domains' && <DomainSideBar domain={props} />}
        {props?.collection === 'channels' && <ChannelSideBar channel={props} />}
      </aside>
    </div>
    <ViewTransitions />
  </main>

  <style is:global>
    .docs-layout .prose {
      max-width: none;
      overflow: auto;
    }

    .mermaid svg {
      margin: 1em auto 2em;
    }

    /* Fix for architecture diagrams */
    .mermaid[data-content*='architecture'] svg {
      max-width: 350px !important;
      margin: 0;
      /* width: 100px !important; */
    }
  </style>

  <script define:vars={{ props, config }}>
    // Fix to pass information to componets that are client side only
    // and require catalog information
    window.eventcatalog = {};
    // @ts-ignore
    window.eventcatalog[`${props.collection}-${props.data.id}`] = props.catalog;

    window.eventcatalog.mermaid = config.mermaid;
  </script>

  <script>
    // Listen for Astro transititions
    document.addEventListener('astro:page-load', () => {
      const graphs = document.getElementsByClassName('mermaid');
      if (document.getElementsByClassName('mermaid').length > 0) {
        renderDiagrams(graphs);
      }
    });

    /**
     * @params {HTMLCollectionOf<HTMLElement>} graphs
     */
    async function renderDiagrams(graphs: any) {
      const { default: mermaid } = await import('mermaid');

      if (window.eventcatalog.mermaid) {
        const { icons } = await import('@iconify-json/logos');
        const { iconPacks = [] } = window.eventcatalog.mermaid ?? {};

        if (iconPacks.length > 0) {
          const iconPacksToRegister = iconPacks.map((name: string) => {
            return {
              name,
              icons,
            };
          });

          mermaid.registerIconPacks(iconPacksToRegister);
        }
      }

      mermaid.initialize({
        // fontSize: 2,
        flowchart: {
          curve: 'linear',
          rankSpacing: 0,
          nodeSpacing: 0,
        },
        startOnLoad: false,
        fontFamily: 'var(--sans-font)',
        // @ts-ignore This works, but TS expects a enum for some reason
        theme: 'light',
        architecture: {
          useMaxWidth: true,
        },
      });

      for (const graph of graphs) {
        const content = graph.getAttribute('data-content');
        if (!content) continue;
        let svg = document.createElement('svg');
        const id = (svg.id = 'mermaid-' + Math.round(Math.random() * 100000));
        graph.appendChild(svg);
        mermaid.render(id, content).then((result) => {
          graph.innerHTML = result.svg;
        });
      }
    }

    const graphs = document.getElementsByClassName('mermaid');
    if (document.getElementsByClassName('mermaid').length > 0) {
      renderDiagrams(graphs);
    }
  </script>
</VerticalSideBarLayout>
