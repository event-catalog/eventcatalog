---
import VerticalSideBarLayout from '@layouts/VerticalSideBarLayout.astro';
import Footer from '@layouts/Footer.astro';
import { marked } from 'marked';

import components from '@components/MDX/components';
import NodeGraph from '@components/MDX/NodeGraph/NodeGraph.astro';
import SchemaViewer from '@components/MDX/SchemaViewer/SchemaViewerRoot.astro';
import Admonition from '@components/MDX/Admonition';

// SideBars
import ServiceSideBar from '@components/SideBars/ServiceSideBar.astro';
import MessageSideBar from '@components/SideBars/MessageSideBar.astro';
import DomainSideBar from '@components/SideBars/DomainSideBar.astro';
import ChannelSideBar from '@components/SideBars/ChannelSideBar.astro';
import FlowSideBar from '@components/SideBars/FlowSideBar.astro';

import { QueueListIcon, RectangleGroupIcon, ServerIcon, BoltIcon, ChatBubbleLeftIcon } from '@heroicons/react/24/outline';
import { ArrowsRightLeftIcon } from '@heroicons/react/20/solid';

import type { PageTypes } from '@types';
import type { CollectionTypes } from '@types';

import { ClientRouter } from 'astro:transitions';
import { render } from 'astro:content';
import type { CollectionEntry } from 'astro:content';

import { getIcon } from '@utils/badges';
import { getDeprecatedDetails } from '@utils/collections/util';
import { pageDataLoader } from '@utils/page-loaders/page-data-loader';
import { buildUrl } from '@utils/url-builder';
import config from '@config';

export async function getStaticPaths() {
  const itemTypes: PageTypes[] = ['events', 'commands', 'queries', 'services', 'domains', 'flows', 'channels'];
  const allItems = await Promise.all(itemTypes.map((type) => pageDataLoader[type]()));

  return allItems.flatMap((items, index) =>
    items.map((item) => ({
      params: {
        type: itemTypes[index],
        id: item.data.id,
        version: item.data.version,
      },
      props: {
        type: itemTypes[index],
        ...item,
      },
    }))
  );
}

const props = Astro.props;

const { Content } = await render(props);
// const { Content } = await props.render();

// Capitalize the first letter of a string
const pageTitle = `${props.collection} | ${props.data.name}`.replace(/^\w/, (c) => c.toUpperCase());
const contentBadges = props.data.badges || [];

const getContentBadges = () =>
  contentBadges.map((badge) => ({
    ...badge,
    icon: badge.icon ? getIcon(badge.icon) : null,
  }));

const getBadge = () => {
  if (props.collection === 'services') {
    return { backgroundColor: 'pink', textColor: 'pink', content: 'Service', icon: ServerIcon, class: 'text-pink-400' };
  }
  if (props.collection === 'events') {
    return { backgroundColor: 'orange', textColor: 'orange', content: 'Event', icon: BoltIcon, class: 'text-orange-400' };
  }
  if (props.collection === 'commands') {
    return { backgroundColor: 'blue', textColor: 'blue', content: 'Command', icon: ChatBubbleLeftIcon, class: 'text-blue-400' };
  }
  if (props.collection === 'domains') {
    return {
      backgroundColor: 'yellow',
      textColor: 'yellow',
      content: 'Domain',
      icon: RectangleGroupIcon,
      class: 'text-yellow-400',
    };
  }

  if (props.collection === 'flows') {
    return { backgroundColor: 'teal', textColor: 'teal', content: 'Flow', icon: QueueListIcon, class: 'text-gray' };
  }

  if (props.collection === 'channels') {
    return { backgroundColor: 'teal', textColor: 'teal', content: 'Channel', icon: ArrowsRightLeftIcon, class: 'text-gray' };
  }

  return { backgroundColor: 'teal', textColor: 'teal', content: '', icon: QueueListIcon, class: 'text-gray' };
};

const getSpecificationBadges = () => {
  const badges = [];
  const hasOpenAPISpec = !!props.data.specifications?.openapiPath;
  const hasAsyncAPISpec = !!props.data.specifications?.asyncapiPath;

  if (hasOpenAPISpec) {
    badges.push({
      backgroundColor: 'white',
      textColor: 'gray',
      content: 'OpenAPI Spec',
      iconURL: buildUrl('/icons/openapi.svg', true),
      class: 'text-black hover:underline',
      id: 'open-api-badge',
      url: buildUrl(`/docs/${props.collection}/${props.data.id}/${props.data.version}/spec`),
    });
  }

  if (hasAsyncAPISpec) {
    badges.push({
      backgroundColor: 'white',
      textColor: 'gray',
      content: 'AsyncAPI Spec',
      iconURL: buildUrl('/icons/asyncapi.svg', true),
      class: 'text-black hover:underline',
      id: 'asyncapi-badge',
      url: buildUrl(`/docs/${props.collection}/${props.data.id}/${props.data.version}/asyncapi`),
    });
  }

  return badges;
};

const badges = [getBadge(), ...getContentBadges(), ...getSpecificationBadges()];

// Index only the latest version
const pagefindAttributes =
  props.data.version === props.data.latestVersion
    ? {
        'data-pagefind-body': '',
        'data-pagefind-meta': `title:${pageTitle}`,
      }
    : {};

const {
  hasDeprecated,
  message: deprecatedMessage,
  isMarkedAsDeprecated,
  deprecatedDate: formattedDate,
} = getDeprecatedDetails(props as unknown as CollectionEntry<CollectionTypes>);

let friendlyCollectionName = props.collection.slice(0, props.collection.length - 1);
friendlyCollectionName = friendlyCollectionName === 'querie' ? 'query' : friendlyCollectionName;
---

<VerticalSideBarLayout title={pageTitle} description={props.data.summary}>
  <main class="flex sm:px-8 docs-layout h-full" {...pagefindAttributes}>
    <div class="flex docs-layout w-full">
      <div class="w-full lg:mr-2 pr-8 overflow-y-auto py-8">
        <div class="border-b border-gray-200 md:pb-2">
          <div>
            <h2
              id="doc-page-header"
              class={`text-2xl md:text-4xl font-bold text-black ${props.data.deprecated && hasDeprecated ? 'text-red-500' : ''}`}
            >
              {props.data.name}
              <span class="">(v{props.data.version})</span>
            </h2>
            {
              isMarkedAsDeprecated && hasDeprecated && (
                <Admonition
                  className="w-full"
                  type="alert"
                  title={formattedDate ? `This ${friendlyCollectionName} was deprecated on ${formattedDate}` : `Deprecated`}
                >
                  <div>
                    {!deprecatedMessage && (
                      <p>
                        The {friendlyCollectionName} has been marked as deprecated
                        {formattedDate && ` on ${formattedDate}`}.
                      </p>
                    )}
                    {deprecatedMessage && <div class="prose prose-sm max-w-none" set:html={marked.parse(deprecatedMessage)} />}
                  </div>
                </Admonition>
              )
            }
            {
              isMarkedAsDeprecated && !hasDeprecated && (
                <Admonition type="warning" title={`This ${friendlyCollectionName} will be deprecated on ${formattedDate}`}>
                  <div>
                    {!deprecatedMessage && (
                      <p>
                        The {friendlyCollectionName} will be deprecated on {formattedDate}.
                      </p>
                    )}
                    {deprecatedMessage && <div class="prose prose-sm max-w-none" set:html={marked.parse(deprecatedMessage)} />}
                  </div>
                </Admonition>
              )
            }

            <h2 class="text-lg pt-2 text-gray-500 font-light">{props.data.summary}</h2>
            {
              badges && (
                <div class="flex flex-wrap py-2 pt-4">
                  {badges.map((badge: any) => {
                    return (
                      <a href={badge.url || '#'} class="pb-2">
                        <span
                          id={badge.id || ''}
                          class={`text-sm font-light text-gray-500 px-2 py-1 rounded-md mr-2  bg-gradient-to-b  from-${badge.backgroundColor}-100 to-${badge.backgroundColor}-200 space-x-1 border border-${badge.backgroundColor}-200 text-${badge.textColor}-800 flex items-center ${badge.class ? badge.class : ''} `}
                        >
                          {badge.icon && <badge.icon className="w-4 h-4 inline-block mr-1 " />}
                          {badge.iconURL && <img src={badge.iconURL} class="w-5 h-5 inline-block " />}
                          <span>{badge.content}</span>
                        </span>
                      </a>
                    );
                  })}
                </div>
              )
            }
          </div>
        </div>

        <div data-pagefind-ignore>
          {
            props.data.version !== props.data.latestVersion && (
              <div class="rounded-md bg-gradient-to-r from-purple-50 to-purple-100 p-4 not-prose my-4">
                <div class="flex">
                  <div class="flex-shrink-0">
                    <svg class="h-5 w-5 text-purple-400" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                      <path
                        fill-rule="evenodd"
                        d="M8.485 2.495c.673-1.167 2.357-1.167 3.03 0l6.28 10.875c.673 1.167-.17 2.625-1.516 2.625H3.72c-1.347 0-2.189-1.458-1.515-2.625L8.485 2.495zM10 5a.75.75 0 01.75.75v3.5a.75.75 0 01-1.5 0v-3.5A.75.75 0 0110 5zm0 9a1 1 0 100-2 1 1 0 000 2z"
                        clip-rule="evenodd"
                      />
                    </svg>
                  </div>
                  <div class="ml-3">
                    <h3 class="text-sm font-medium text-purple-800">New version found</h3>
                    <div class="mt-2 text-sm text-purple-700">
                      <p>
                        You are looking at a previous version of the {props.collection.slice(0, props.collection.length - 1)}{' '}
                        <strong>{props.data.name}</strong>.{' '}
                        <a
                          class="underline hover:text-primary block pt-2"
                          href={buildUrl(`/docs/${props.collection}/${props.data.id}/${props.data.latestVersion}`)}
                        >
                          The latest version of this {props.collection.slice(0, props.collection.length - 1)} is
                          <span>v{props.data.latestVersion}</span> &rarr;
                        </a>
                      </p>
                    </div>
                  </div>
                </div>
              </div>
            )
          }
        </div>

        <div class="prose prose-md py-4 w-full">
          <Content components={components(props)} />
        </div>
        <div data-pagefind-ignore>
          <!-- @ts-ignore -->
          <!-- <SchemaViewer id={props.data.id} catalog={props.catalog} filePath={props.filePath} /> -->
          <SchemaViewer id={props.data.id} filePath={props.filePath} />
          <NodeGraph
            id={props.data.id}
            collection={props.collection}
            version={props.data.version}
            mode="simple"
            linksToVisualiser={true}
            href={{
              label: 'Open in Visualiser',
              url: buildUrl(`/visualiser/${props.collection}/${props.data.id}/${props.data.version}`),
            }}
          />
        </div>
        <Footer />
      </div>
      <aside class="hidden lg:block sticky top-0 pb-10 w-96 overflow-y-auto py-2" data-pagefind-ignore>
        <!-- @ts-ignore -->
        {
          (props?.collection === 'events' || props.collection === 'commands' || props.collection === 'queries') && (
            <MessageSideBar message={props} />
          )
        }
        {props?.collection === 'services' && <ServiceSideBar service={props} />}
        {props?.collection === 'domains' && <DomainSideBar domain={props} />}
        {props?.collection === 'channels' && <ChannelSideBar channel={props} />}
        {props?.collection === 'flows' && <FlowSideBar flow={props} />}
      </aside>
    </div>
    <ClientRouter />
  </main>

  <style is:global>
    .docs-layout .prose {
      max-width: none;
      overflow: auto;
    }

    .mermaid svg {
      margin: 1em auto 2em;
    }

    /* Fix for architecture diagrams */
    .mermaid[data-content*='architecture'] svg {
      max-width: 350px !important;
      margin: 0;
      /* width: 100px !important; */
    }
  </style>

  <script define:vars={{ props, config }}>
    // Fix to pass information to componets that are client side only
    // and require catalog information
    window.eventcatalog = {};
    // @ts-ignore
    window.eventcatalog[`${props.collection}-${props.data.id}`] = props.catalog;

    window.eventcatalog.mermaid = config.mermaid;
  </script>

  <script>
    // Listen for Astro transititions
    document.addEventListener('astro:page-load', () => {
      const graphs = document.getElementsByClassName('mermaid');
      if (document.getElementsByClassName('mermaid').length > 0) {
        renderDiagrams(graphs);
      }
    });

    /**
     * Renders mermaid diagrams in the page
     * @param {HTMLCollectionOf<HTMLElement>} graphs - The collection of mermaid graph elements
     */
    async function renderDiagrams(graphs: any) {
      const { default: mermaid } = await import('mermaid');

      if (window.eventcatalog.mermaid) {
        const { icons } = await import('@iconify-json/logos');
        const { iconPacks = [] } = window.eventcatalog.mermaid ?? {};

        if (iconPacks.length > 0) {
          const iconPacksToRegister = iconPacks.map((name: any) => {
            return {
              name,
              icons,
            };
          });

          mermaid.registerIconPacks(iconPacksToRegister);
        }
      }

      mermaid.initialize({
        // fontSize: 2,
        flowchart: {
          curve: 'linear',
          rankSpacing: 0,
          nodeSpacing: 0,
        },
        startOnLoad: false,
        fontFamily: 'var(--sans-font)',
        // @ts-ignore This works, but TS expects a enum for some reason
        theme: 'light',
        architecture: {
          useMaxWidth: true,
        },
      });

      for (const graph of graphs) {
        const content = graph.getAttribute('data-content');
        if (!content) continue;
        let svg = document.createElement('svg');
        const id = (svg.id = 'mermaid-' + Math.round(Math.random() * 100000));
        graph.appendChild(svg);
        mermaid.render(id, content).then((result) => {
          graph.innerHTML = result.svg;
        });
      }
    }

    const graphs = document.getElementsByClassName('mermaid');
    if (document.getElementsByClassName('mermaid').length > 0) {
      renderDiagrams(graphs);
    }
  </script>
</VerticalSideBarLayout>
