---
// import { createRxDatabase, removeRxDatabase, addRxPlugin } from 'rxdb';
// import { getRxStorageDexie } from 'rxdb/plugins/storage-dexie';
// // import { RxDBDevModePlugin } from 'rxdb/plugins/dev-mode';
// import { RxDBMigrationSchemaPlugin } from 'rxdb/plugins/migration-schema';
// import { RxDBQueryBuilderPlugin } from 'rxdb/plugins/query-builder';
// import { RxDBUpdatePlugin } from 'rxdb/plugins/update';

// addRxPlugin(RxDBQueryBuilderPlugin);
// addRxPlugin(RxDBMigrationSchemaPlugin);
// addRxPlugin(RxDBUpdatePlugin);

// addRxPlugin(RxDBDevModePlugin);

// const itemsCollection = db.items;
// const vectorCollection = db.vector;

// import { getEvents } from '@utils/events';
// import { pipeline } from '@huggingface/transformers';

// const pipePromise = pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
// async function getEmbeddingFromText(text: string) {
//   const pipe = await pipePromise;
//   const output = await pipe(text, {
//     pooling: "mean",
//     normalize: true,
//   });
//   return Array.from(output.data);
// }

// const test = await getEmbeddingFromText('Hello, world!');
// console.log(test);

// const events = await getEvents();
// const eventsToEmbed = events[0];

// // Get the markdown for the events

// const embeddings = await Promise.all(eventsToEmbed.map(async (event: any) => {
//   const text = `# ${event.data.name}\n${event.data.summary}`;
//   const embedding = await getEmbeddingFromText(text);
//   return {
//     id: event.id,
//     embedding: embedding
//   };
// }));

// console.log(embeddings);

// const answerer = await pipeline('question-answering', 'Xenova/distilbert-base-uncased-distilled-squad');

// const events = await getEvents();

// // Fetch info from http://localhost:3000/docs/llm/llms.txt
// const llms = await fetch('http://localhost:3000/docs/llm/llms.txt');
// const context = await llms.text();

// console.log('events', events);

// // Get all events as the context
// // const context = events.map((event: any) => `There are 1000 events in this catalog`).join('\n');

// console.log(context);

// const question = 'Here is a list of events in markdown, tell me how many events there are';

// // https://huggingface.co/models?pipeline_tag=question-answering&library=transformers.js

// const result = await answerer(question, context);

// console.log(result);
---

<div>
  <ul id="results"></ul>
  <!-- <p>Result: {JSON.stringify(result)}</p> -->
</div>

<script>
  import { createRxDatabase, removeRxDatabase, addRxPlugin } from 'rxdb';
  import { getRxStorageDexie } from 'rxdb/plugins/storage-dexie';
  import { pipeline } from '@huggingface/transformers';
  // import { RxDBDevModePlugin } from 'rxdb/plugins/dev-mode';
  import { RxDBMigrationSchemaPlugin } from 'rxdb/plugins/migration-schema';
  import { RxDBQueryBuilderPlugin } from 'rxdb/plugins/query-builder';
  import { RxDBUpdatePlugin } from 'rxdb/plugins/update';
  import { euclideanDistance } from 'rxdb/plugins/vector';
  import { getFromMapOrThrow } from 'rxdb/plugins/core';
  import { sortByObjectNumberProperty } from 'rxdb/plugins/core';
  import embeddings from '../ai/eventcatalog/embeddings.json';
  import items from '../ai/eventcatalog/resources.json';


  const pipePromise = pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');

  const getVectorFromText = async (text: string) => {
    const pipe = await pipePromise;
    const output = await pipe(text, {
      pooling: 'mean',
      normalize: true,
    });
    return Array.from(output.data);
  };

  const main = async () => {
    let database;

    database = await createRxDatabase({
      name: Math.random().toString(36).substring(2, 15),
      storage: getRxStorageDexie(),
      //   ignoreDuplicate: true,
    });

    await database.addCollections({
      items: {
        schema: {
          version: 0,
          primaryKey: 'id',
          type: 'object',
          properties: {
            id: {
              type: 'string',
              maxLength: 20,
            },
            text: {
              type: 'string',
            },
          },
          required: ['id', 'text'],
        },
      },
      vector: {
        schema: {
          version: 0,
          primaryKey: 'id',
          type: 'object',
          properties: {
            id: {
              type: 'string',
              maxLength: 20,
            },
            embedding: {
              type: 'array',
              items: {
                type: 'string',
              },
            },
          },
          required: ['id', 'embedding'],
        },
      },
    });

    // Get the items
    console.log('embeddingsResponse', embeddings)

    // Insert the embeddings into the vector collection
    const vectorInsertResult = await database.vector.bulkInsert(
        embeddings
    );
    console.dir({ vectorInsertResult, embeddings });

    // Insert the items into the items collection
    await database.items.bulkInsert(
        items
    );

    async function vectorSearchFullScan(vectorCollection: RxCollection, searchEmbedding: number[]) {
        const candidates = await vectorCollection.find().exec();
        console.log('after fetch ' + performance.now());
        const withDistance = candidates.map(doc => ({ doc, distance: euclideanDistance(searchEmbedding, doc.embedding) }))
        console.log('after distance ' + performance.now());
        const queryResult = withDistance.slice(0).sort(sortByObjectNumberProperty('distance')).reverse();
        console.log('after sorted ' + performance.now());
        console.dir({ withDistance, queryResult });
        return {
            result: queryResult.slice(0, 10),
            docReads: candidates.length
        };
    };


    // const itemsCollection = database.items;
    // const vectorCollection = database.vector;

    // const embedding = await getVectorFromText('Dave is a new yorker');

    // console.log(embedding);

    // await vectorCollection.upsert({
    //   id: 1,
    //   embedding,
    // });

    const userInput = 'Events owned by dboyne';

    const searchEmbedding = await getVectorFromText(userInput);

    // time('START SEARCH vectorSearchFullScan ' + performance.now());
    const results = await vectorSearchFullScan(database.vector, searchEmbedding);
    // const queryResultFullScanTime = time('DONE SEARCH vectorSearchFullScan ' + performance.now());
    console.log({ results });

    const sourceDocs = await database.items.findByIds(results.result.map((r: any) => r.doc.primary)).exec();

    console.log('sourceDocs', sourceDocs)

    const testing = results.result.map((r: any, idx) => {
          const doc = getFromMapOrThrow(sourceDocs, r.doc.primary);
          console.log('doc', doc)
          // Add an LI to the results list add the doc._data.id and the doc._data.name
          const li = document.createElement('li');
          li.textContent = `${doc._data.id} - ${doc._data.name}`;
          document.getElementById('results')?.appendChild(li);
      }).join('');

    console.log('testing', testing)

    // const queryResult = withDistance.sort(sortByObjectNumberProperty('distance')).reverse();
    // console.dir(queryResult);

    // await itemsCollection.insert({
    //   id: '1',
    //   text: 'Hello, world!',
    // });

    // This will get the items and embed them into IndedDB and Vector store
    // Then search the vector store for the closest matches
    // Then return the items and the matches based on user input search....

  };

  main();
</script>
